# 스윙 언어 문서 v0.5

SWING언어의 문법을 정리한 문서입니다.

마지막 수정 - 2017/08/23

# 문법

특징은 문장 끝의 세미콜론 없이 개행으로 한 명령문을 처리합니다.
제어문의 조건식의 괄호가 생략가능합니다.

SWING Lexer에서 사용되어지는 정규식입니다.

```
// 식별자 - 함수명, 변수명, 타입명
Identifier ::= [a-zA-Z_][0-9a-zA-z_]*

// 수
Integer ::= [0-9][0-9]*
Hexa ::= 0x[0-9a-fA-F][0-9a-fA-F]*
Octal ::= 0o[0-7][0-7]*
Binary ::= 0b[01][01]*
Double ::= [0-9][0-9]*.[0-9][0-9]*

//문자열
Character ::= '_|[\][ntr0\'"]'

// escape 문자
Escape_sequence ::= [\]n | [\]t | [\]r | [\]0 | [\]\ | [\]' | [\]"
```

추후 EBNF로 문법을 상세히 정리할 예정입니다.

## 자료형

자료형은 자주 사용되는 여러 정수형, 실수형 자료형으로 구성했습니다.

지원하는 자료형

* bool
* char
* int
* float
* double

사용자 정의 타입

* struct
* protocol

### 변수

자료형은 다음과 같이 선언가능 합니다.

```swift
var 변수명 = 값 //변수 선언
```
var 키워드로 변수를 선언할 수 있습니다.
SWING은 할당하는 값의 타입을 추론해 그 값의 타입으로 변수를 생성합니다.

물론 아래와 같이 타입을 지정할 수 있습니다.

```swift
var 변수명           //불가능! 타입을 추론할 수 없음
var 변수명 = 값      //가능! 값과 같은 타입으로 생성
var 변수명:타입      //가능! 명시된 타입으로 생성
```

#### 기본 자로형

키워드 | 크기 | 용도
---|------|-----
bool | 1Bit | 논리 연산
char | 1Byte | 문자 표현
int | 4Byte | 정수 표현
float | 4Byte | 부동 소수점 표현
double | 8Byte | 부동 소수점 표현


## 연산자

다음과 같은 연산자를 지원합니다.

### 할당연산자

연산자 | 사용 예 | 결과
----|-------|-----
= | a = b | a 에 b를 할당, 반환값 없음!

### 산술연산자

연산자 | 사용 예 | 결과값
----|-------|-----
\+ | a \+ b | a와 b를 더한 값
\- | a \- b | a에 b를 뺀 값
\* | a \* b | a와 b를 곱한 값
\/ | a \/ b | a에 b를 나눴을 때 몫
\% | a \% b | a에 b를 나눴을 때 나머지

나머지 연산자인 %는 실수형에도 연산이 가능합니다.

### 비교연산자

a 와 b를 비교했을 때 a의 입장에서 설명하면 아래와 같이 설명할 수 있습니다.

비교 연산자의 반환값은 오직 Bool형입니다. 다른 타입이 될 수 없습니다.

연산자 | 사용 예 | 설명
----|-------|-------
\> | a \> b | 크다
\< | a \< b | 작다
\>= | a \>= b | 크거나 같다
\<= | a \<= b | 작거나 같다
\== | a \== b | 같다
\!= | a \!= b | 같지 않다

### 논리연산자

논리 연산자의 반환값은 오직 Bool형입니다. 다른 타입이 될 수 없습니다.

연산자 | 사용 예 | 설명
----|-------|-------
&& | a && b | a 그리고 b
\|\| | a \|\| b | a 또는 b
! | !a | a가 아니다

## 제어문

제어문은 if, else, guard, switch, while, for를 제공합니다.

각 제어문의 조건식에 괄호가 요구되지 않습니다.
if문과 블럭 사이의 표현식을 평가하여 올바른 결과값을 도출합니다.
괄호를 사용해도 무관합니다.

### if else문
if else의 형태입니다.
```swift
if condition {
    //작업...
}
else {
    //작업...
}
```

if else는 중첩이 가능하며 아래와 같이 사용할 수 있습니다.
```swift
if n == 1 {
    DoSomething1()
}
else if n == 2 {
    DoSomething2()
}
else {
    DoSomethingelse()
}
```

### while문

일반적인 while문과 동일합니다. condition이 참일 때 반복합니다.

while문의 형태입니다.

```swift
while condition {
    //작업...
}
```

### for문

for문은 초기화, 조건식, 증감문으로 일반적인 구성을 지니고 있습니다.


가장 기본적인 형태입니다.
```swift
for initial; condition; increament {
    //작업...
}
```

### break문
break문은 while문이나 for문 스코프 내에서 사용가능합니다.

### return문 (미완성)
return문은 함수내에서 사용가능하며 모든함수에서 마지막에 한번 실행 될 수 있습니다.
return문을 여러번 사용할 수 없습니다. 빠른시일내에 개선하겠습니다.

반환값이 void일 때는 ```return void```를 사용하면 됩니다.

## 함수

함수를 통해 사용자가 원하는 프로그램 코드를 묶을 수 있고 재사용 할 수 있습니다.

```swift
func FunctionName(Arg1:Type, Arg2:Type) -> ReturnType {
    //작업...
}
```

## 프로토콜 지향 프로그래밍

### struct

struct를 사용해 사용자 정의 타입을 선언할 수 있습니다. 대부분의 언어에서와 유사한 문법을 가집니다.

```swift
struct name {
    // do something...
}
```

SWING의 struct는 다음과 같은 특징을 가지고 있습니다.

* 프로토콜을 준수할 수 있습니다.
* 다형성을 지원합니다. (프로토콜 활용)

### protocol

POP의 핵심 개념중 하나인 Protocol입니다.

protocol은 blueprint입니다. 미리 구현할 것을 설계하고 이를 준수하여 구현하는 메커니즘입니다.

```swift
protocol name {
    // do something...
}
```

프로토콜은 다른 프로토콜을 준수할 수 없으며 메소드를 선언할 수는 있지만 정의할 수 없습니다.

프로토콜은 상속과 달리 수평확장이라 변수가 객체내부에 직접적으로 선언되어 집니다.

프로토콜의 기본 기능을 정의하려면 extension을 활용하세요.

### extension

extension을 통해 해당 타입이 특정 프로토콜을 준수할 수 있도록 설정할 수 있습니다. 프로토콜을 준수하게 되면 해당 메소드나 변수를 정의해야 합니다.

```swift
extension 대상 : 프로토콜 {
    // do something
}
```

### self
모든 인스턴스의 메소드에는 암시적으로 self를 담게 하고 있습니다. self는 자기 자신을 참조하는 변수입니다.

```swift
struct Test {
    var member:int = 0
    
    func method() -> void
    {
        self.member = 10
        return void
    }
}
```
